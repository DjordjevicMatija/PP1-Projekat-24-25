package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    boolean errorDetected = false;
    Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal SEMICOLON, COMMA, LPARENT, RPARENT, LBRACKET, RBRACKET, LBRACE, RBRACE;
terminal PROG, CONST, NEW, RETURN, VOID, UNION, MAP;
terminal BREAK, IF, ELSE, CONTINUE, DO, WHILE;
terminal PRINT, READ;
terminal PLUS, MINUS, MUL, DIV, MOD, INC, DEC, ASSIGN;
terminal AND, OR;
terminal EQUALS, NOT_EQUALS, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;
terminal String IDENT;
terminal COLON, DOT, CLASS, EXTENDS, INTERFACE;

nonterminal Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName;
nonterminal DeclList;
nonterminal Decl;
nonterminal ConstDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal ConstList;
nonterminal Const;
nonterminal VarDecl;
nonterminal VarList;
nonterminal Var;
nonterminal MethodDeclList;
nonterminal MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodName;
nonterminal MethodPars;
nonterminal FormPars;
nonterminal FormParam;
nonterminal MethodVarDeclList;
nonterminal StatementList;
nonterminal Statement;
nonterminal UnmatchedStatement;
nonterminal MatchedStatement;
nonterminal Else;
nonterminal DoWhileLoop;
nonterminal DoWhileStepStatement;
nonterminal DesignatorStatement;
nonterminal SimpleDesignatorStmt;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondTermList;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondTerm;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFactList;
nonterminal rs.etf.pp1.symboltable.concepts.Struct CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr;
nonterminal rs.etf.pp1.symboltable.concepts.Struct TermList;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator;
nonterminal OptActPars;
nonterminal ActParsBegin;
nonterminal ActPars;
nonterminal rs.etf.pp1.symboltable.concepts.Obj DesignatorName;
nonterminal Label;
nonterminal Assignop;
nonterminal Relop;
nonterminal Addop;
nonterminal Mulop;
nonterminal Setop;

Program ::= (Program)
    PROG ProgName:pName DeclList LBRACE MethodDeclList RBRACE
;

ProgName ::= (ProgName)
    IDENT:progName
;

DeclList ::=
    (DeclarationList) DeclList Decl
    | (NoDeclarationList) /* epsilon */
;

Decl ::=
    (ConstDeclaration) ConstDecl
    | (VarDeclaration) VarDecl
;

ConstDecl ::=
    (ConstantDeclaration) CONST Type ConstList SEMICOLON
    | (ErrorConstDeclSemi) CONST error SEMICOLON:err
        {: parser.report_error("Uspesan oporavak od greske pri definiciji globalne konstante na liniji " + errleft, null); :}
;

Type ::= (Type)
    IDENT:typeName
;

ConstList ::=
    (ConstantList) ConstList COMMA Const
    | (SingleConst) Const
    | (ErrorConstDeclComma) error:err
        {: parser.report_error("Uspesan oporavak od greske pri definiciji globalne konstante na liniji " + errleft, null); :}
;

Const ::=
    (NumberConst) IDENT:constName ASSIGN NUMBER
    | (CharConst) IDENT:constName ASSIGN CHAR
    | (BoolConst) IDENT:constName ASSIGN BOOL
;

VarDecl ::=
    (VariableDeclaration) Type VarList SEMICOLON
    | (ErrorVarDeclSemi) error SEMICOLON:err
        {: parser.report_error("Uspesan oporavak od greske pri definiciji promenljive na liniji " + errleft, null); :}
;

VarList ::=
    (VariableList) VarList COMMA Var
    | (SingleVar) Var
;

Var ::=
    (VarElem) IDENT:varName
    | (VarArray) IDENT:varName LBRACKET RBRACKET
    | (ErrorVarDeclComma) error:err
        {: parser.report_error("Uspesan oporavak od greske pri definiciji promenljive na liniji " + errleft, null); :}
;

MethodDeclList ::=
    (MethodDeclarationList) MethodDeclList MethodDecl
    | (NoMethodDeclarationList) /* epsilon */
;

MethodDecl ::= (MethodDecl)
    MethodName:mName LPARENT MethodPars RPARENT MethodVarDeclList LBRACE StatementList RBRACE
;

MethodName ::=
    (TypeMethodName) Type:returnType IDENT:methodName
    | (VoidMethodName) VOID IDENT:methodName
;

MethodPars ::=
    (MethodParameters) FormPars
    | (NoMethodParameters) /* epsilon */
;

FormPars ::=
    (FormParamList) FormPars COMMA FormParam
    | (SingleFormParam) FormParam
;

FormParam ::=
    (FormParamElement) Type:paramType IDENT:paramName
    | (FormParamArray) Type:paramType IDENT:paramName LBRACKET RBRACKET
    | (ErrorFormParameter) error:err
        {: parser.report_error("Uspesan oporavak od greske pri definiciji parametara metode na liniji " + errleft, null); :}
;

MethodVarDeclList ::=
    (MethodVarDeclarations) MethodVarDeclList VarDecl
    | (NoMethodVarDeclarations) /* epsilon */
;

StatementList ::=
    (Statements) StatementList Statement
    | (NoStatements) /* epsilon */
;

Statement ::=
    (UnmatchedStmt) UnmatchedStatement
    | (MatchedStmt) MatchedStatement
;

UnmatchedStatement ::=
    (UnmatchedIf) IF LPARENT Condition RPARENT Statement
    | (UnmatchedIfElse) IF LPARENT Condition RPARENT MatchedStatement Else UnmatchedStatement
;

MatchedStatement ::=
    (MatchedIf) IF LPARENT Condition RPARENT MatchedStatement Else MatchedStatement
    | (DesignStmt) DesignatorStatement
    | (BreakStmt) BREAK SEMICOLON
    | (ContinueStmt) CONTINUE SEMICOLON
    | (ReturnStmt) RETURN SEMICOLON
    | (ReturnExprStmt) RETURN Expr SEMICOLON
    | (ReadStmt) READ LPARENT Designator RPARENT SEMICOLON
    | (PrintExpr) PRINT LPARENT Expr RPARENT SEMICOLON
    | (PrintExprNumber) PRINT LPARENT Expr COMMA NUMBER RPARENT SEMICOLON
    | (DoWhileStmt) DoWhileLoop Statement WHILE LPARENT RPARENT SEMICOLON
    | (DoWhileConditionStmt) DoWhileLoop Statement WHILE LPARENT Condition RPARENT SEMICOLON
    | (DoWhileConditionStepStmt) DoWhileLoop Statement WHILE LPARENT Condition COMMA DoWhileStepStatement RPARENT SEMICOLON
    | (StmtList) LBRACE StatementList RBRACE
;

Else ::= (Else)
    ELSE
;

DoWhileLoop ::= (DoWhileLoop)
    DO
;

DoWhileStepStatement ::= (DoWhileStepStatement)
    SimpleDesignatorStmt
;

DesignatorStatement ::=
    (DesignatorStmt) SimpleDesignatorStmt SEMICOLON
    | (ErrorDesignAssign) error SEMICOLON:err
        {: parser.report_error("Uspesan oporavak od greske pri konstrukciji iskaza dodele na liniji " + errleft, null); :}
;

SimpleDesignatorStmt ::=
    (DesignAssign) Designator:design Assignop Expr
    | (DesignFunc) Designator:func LPARENT OptActPars RPARENT
    | (DesignInc) Designator:design INC
    | (DesignDec) Designator:design DEC
    | (DesignUnion) Designator Assignop Designator Setop Designator
;

OptActPars ::=
    (ActParameters) ActParsBegin ActPars
    | (NoActParameters) ActParsBegin /* epsilon */
;

ActParsBegin ::= (ActParsBegin)
    /* epsilon */
;

ActPars ::=
    (SingleActParam) Expr:e
    | (ActParamList) ActPars COMMA Expr:e
;

Condition ::= (Condition)
    CondTermList
;

CondTermList ::=
    (SingleConditionTerm) CondTerm
    | (ConditionTermList) CondTermList OR CondTerm
    | (ErrorCondition) error:err
        {: parser.report_error("Uspesan oporavak od greske pri logickom izrazu if naredbe na liniji " + errleft, null); :}
;

CondTerm ::= (CondTerm)
    CondFactList
;

CondFactList ::=
    (SingleConditionFact) CondFact
    | (ConditionFactList) CondFactList AND CondFact
;

CondFact ::=
    (SingleCondition) Expr
    | (ConditionList) Expr Relop Expr
;

Expr ::=
    (TermListExpr) TermList
    | (MapExpr) Designator:func MAP Designator:arr
;

TermList ::=
    (SingleTerm) Term
    | (TerminalList) TermList Addop Term
    | (NegativeTerm) MINUS Term
;

Term ::=
    (SingleFactor) Factor
    | (Factors) Term Mulop Factor
;

Factor ::=
    (DesignFactor) Designator:design
    | (DesingFuncFactor) Designator:func LPARENT OptActPars RPARENT
    | (FactorNumber) NUMBER
    | (FactorChar) CHAR
    | (FactorBool) BOOL
    | (FactorNew) NEW Type LBRACKET Expr RBRACKET
    | (FactorExpr) LPARENT Expr RPARENT
;

Designator ::=
    (DesignatorElement) IDENT:designName
    | (DesignatorArray) DesignatorName LBRACKET Expr RBRACKET
;

DesignatorName ::= (DesignatorName)
    IDENT:designName
;

Label ::= (Label)
    IDENT
;

Assignop ::= (Assignop)
    ASSIGN
;

Relop ::=
    (RelopEquals) EQUALS
    | (RelopNotEquals) NOT_EQUALS
    | (RelopGreater) GREATER
    | (RelopGreaterEqual) GREATER_EQUAL
    | (RelopLess) LESS
    | (RelopLessEqual) LESS_EQUAL
;

Addop ::=
    (AddopPlus) PLUS
    | (AddopMinus) MINUS
;

Mulop ::=
    (MulopMul) MUL
    | (MulopDiv) DIV
    | (MulopMod) MOD
;

Setop ::= (Union)
    UNION
;